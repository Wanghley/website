{"ast":null,"code":"\"use client\";\n\nimport { listenEvent, effect, untrack, createScope, keysOf, onDispose, DOMEvent, peek } from './vidstack-CH225ns1.js';\nimport { ListSymbol, TimeRange, RAFLoop } from './vidstack-C-WrcxmD.js';\nimport { getCastSessionMedia, getCastContext, getCastSession, hasActiveCastSession, listenCastContextEvent, getCastErrorMessage } from './vidstack-C8ZxSSGF.js';\nimport 'react';\nimport '@floating-ui/dom';\nclass GoogleCastMediaInfoBuilder {\n  #info;\n  constructor(src) {\n    this.#info = new chrome.cast.media.MediaInfo(src.src, src.type);\n  }\n  build() {\n    return this.#info;\n  }\n  setStreamType(streamType) {\n    if (streamType.includes(\"live\")) {\n      this.#info.streamType = chrome.cast.media.StreamType.LIVE;\n    } else {\n      this.#info.streamType = chrome.cast.media.StreamType.BUFFERED;\n    }\n    return this;\n  }\n  setTracks(tracks) {\n    this.#info.tracks = tracks.map(this.#buildCastTrack);\n    return this;\n  }\n  setMetadata(title, poster) {\n    this.#info.metadata = new chrome.cast.media.GenericMediaMetadata();\n    this.#info.metadata.title = title;\n    this.#info.metadata.images = [{\n      url: poster\n    }];\n    return this;\n  }\n  #buildCastTrack(track, trackId) {\n    const castTrack = new chrome.cast.media.Track(trackId, chrome.cast.media.TrackType.TEXT);\n    castTrack.name = track.label;\n    castTrack.trackContentId = track.src;\n    castTrack.trackContentType = \"text/vtt\";\n    castTrack.language = track.language;\n    castTrack.subtype = track.kind.toUpperCase();\n    return castTrack;\n  }\n}\nclass GoogleCastTracksManager {\n  #cast;\n  #ctx;\n  #onNewLocalTracks;\n  constructor(cast, ctx, onNewLocalTracks) {\n    this.#cast = cast;\n    this.#ctx = ctx;\n    this.#onNewLocalTracks = onNewLocalTracks;\n  }\n  setup() {\n    const syncRemoteActiveIds = this.syncRemoteActiveIds.bind(this);\n    listenEvent(this.#ctx.audioTracks, \"change\", syncRemoteActiveIds);\n    listenEvent(this.#ctx.textTracks, \"mode-change\", syncRemoteActiveIds);\n    effect(this.#syncLocalTracks.bind(this));\n  }\n  getLocalTextTracks() {\n    return this.#ctx.$state.textTracks().filter(track => track.src && track.type === \"vtt\");\n  }\n  #getLocalAudioTracks() {\n    return this.#ctx.$state.audioTracks();\n  }\n  #getRemoteTracks(type) {\n    const tracks = this.#cast.mediaInfo?.tracks ?? [];\n    return type ? tracks.filter(track => track.type === type) : tracks;\n  }\n  #getRemoteActiveIds() {\n    const activeIds = [],\n      activeLocalAudioTrack = this.#getLocalAudioTracks().find(track => track.selected),\n      activeLocalTextTracks = this.getLocalTextTracks().filter(track => track.mode === \"showing\");\n    if (activeLocalAudioTrack) {\n      const remoteAudioTracks = this.#getRemoteTracks(chrome.cast.media.TrackType.AUDIO),\n        remoteAudioTrack = this.#findRemoteTrack(remoteAudioTracks, activeLocalAudioTrack);\n      if (remoteAudioTrack) activeIds.push(remoteAudioTrack.trackId);\n    }\n    if (activeLocalTextTracks?.length) {\n      const remoteTextTracks = this.#getRemoteTracks(chrome.cast.media.TrackType.TEXT);\n      if (remoteTextTracks.length) {\n        for (const localTrack of activeLocalTextTracks) {\n          const remoteTextTrack = this.#findRemoteTrack(remoteTextTracks, localTrack);\n          if (remoteTextTrack) activeIds.push(remoteTextTrack.trackId);\n        }\n      }\n    }\n    return activeIds;\n  }\n  #syncLocalTracks() {\n    const localTextTracks = this.getLocalTextTracks();\n    if (!this.#cast.isMediaLoaded) return;\n    const remoteTextTracks = this.#getRemoteTracks(chrome.cast.media.TrackType.TEXT);\n    for (const localTrack of localTextTracks) {\n      const hasRemoteTrack = this.#findRemoteTrack(remoteTextTracks, localTrack);\n      if (!hasRemoteTrack) {\n        untrack(() => this.#onNewLocalTracks?.());\n        break;\n      }\n    }\n  }\n  syncRemoteTracks(event) {\n    if (!this.#cast.isMediaLoaded) return;\n    const localAudioTracks = this.#getLocalAudioTracks(),\n      localTextTracks = this.getLocalTextTracks(),\n      remoteAudioTracks = this.#getRemoteTracks(chrome.cast.media.TrackType.AUDIO),\n      remoteTextTracks = this.#getRemoteTracks(chrome.cast.media.TrackType.TEXT);\n    for (const remoteAudioTrack of remoteAudioTracks) {\n      const hasLocalTrack = this.#findLocalTrack(localAudioTracks, remoteAudioTrack);\n      if (hasLocalTrack) continue;\n      const localAudioTrack = {\n        id: remoteAudioTrack.trackId.toString(),\n        label: remoteAudioTrack.name,\n        language: remoteAudioTrack.language,\n        kind: remoteAudioTrack.subtype ?? \"main\",\n        selected: false\n      };\n      this.#ctx.audioTracks[ListSymbol.add](localAudioTrack, event);\n    }\n    for (const remoteTextTrack of remoteTextTracks) {\n      const hasLocalTrack = this.#findLocalTrack(localTextTracks, remoteTextTrack);\n      if (hasLocalTrack) continue;\n      const localTextTrack = {\n        id: remoteTextTrack.trackId.toString(),\n        src: remoteTextTrack.trackContentId,\n        label: remoteTextTrack.name,\n        language: remoteTextTrack.language,\n        kind: remoteTextTrack.subtype.toLowerCase()\n      };\n      this.#ctx.textTracks.add(localTextTrack, event);\n    }\n  }\n  syncRemoteActiveIds(event) {\n    if (!this.#cast.isMediaLoaded) return;\n    const activeIds = this.#getRemoteActiveIds(),\n      editRequest = new chrome.cast.media.EditTracksInfoRequest(activeIds);\n    this.#editTracksInfo(editRequest).catch(error => {\n      {\n        this.#ctx.logger?.errorGroup(\"[vidstack] failed to edit cast tracks info\").labelledLog(\"Edit Request\", editRequest).labelledLog(\"Error\", error).dispatch();\n      }\n    });\n  }\n  #editTracksInfo(request) {\n    const media = getCastSessionMedia();\n    return new Promise((resolve, reject) => media?.editTracksInfo(request, resolve, reject));\n  }\n  #findLocalTrack(localTracks, remoteTrack) {\n    return localTracks.find(localTrack => this.#isMatch(localTrack, remoteTrack));\n  }\n  #findRemoteTrack(remoteTracks, localTrack) {\n    return remoteTracks.find(remoteTrack => this.#isMatch(localTrack, remoteTrack));\n  }\n  // Note: we can't rely on id matching because they will differ between local/remote. A local\n  // track id might not even exist.\n  #isMatch(localTrack, remoteTrack) {\n    return remoteTrack.name === localTrack.label && remoteTrack.language === localTrack.language && remoteTrack.subtype.toLowerCase() === localTrack.kind.toLowerCase();\n  }\n}\nclass GoogleCastProvider {\n  $$PROVIDER_TYPE = \"GOOGLE_CAST\";\n  scope = createScope();\n  #player;\n  #ctx;\n  #tracks;\n  #currentSrc = null;\n  #state = \"disconnected\";\n  #currentTime = 0;\n  #played = 0;\n  #seekableRange = new TimeRange(0, 0);\n  #timeRAF = new RAFLoop(this.#onAnimationFrame.bind(this));\n  #playerEventHandlers;\n  #reloadInfo = null;\n  #isIdle = false;\n  constructor(player, ctx) {\n    this.#player = player;\n    this.#ctx = ctx;\n    this.#tracks = new GoogleCastTracksManager(player, ctx, this.#onNewLocalTracks.bind(this));\n  }\n  get type() {\n    return \"google-cast\";\n  }\n  get currentSrc() {\n    return this.#currentSrc;\n  }\n  /**\n   * The Google Cast remote player.\n   *\n   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.RemotePlayer}\n   */\n  get player() {\n    return this.#player;\n  }\n  /**\n   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastContext}\n   */\n  get cast() {\n    return getCastContext();\n  }\n  /**\n   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastSession}\n   */\n  get session() {\n    return getCastSession();\n  }\n  /**\n   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/chrome.cast.media.Media}\n   */\n  get media() {\n    return getCastSessionMedia();\n  }\n  /**\n   * Whether the current Google Cast session belongs to this provider.\n   */\n  get hasActiveSession() {\n    return hasActiveCastSession(this.#currentSrc);\n  }\n  setup() {\n    this.#attachCastContextEventListeners();\n    this.#attachCastPlayerEventListeners();\n    this.#tracks.setup();\n    this.#ctx.notify(\"provider-setup\", this);\n  }\n  #attachCastContextEventListeners() {\n    listenCastContextEvent(cast.framework.CastContextEventType.CAST_STATE_CHANGED, this.#onCastStateChange.bind(this));\n  }\n  #attachCastPlayerEventListeners() {\n    const Event2 = cast.framework.RemotePlayerEventType,\n      handlers = {\n        [Event2.IS_CONNECTED_CHANGED]: this.#onCastStateChange,\n        [Event2.IS_MEDIA_LOADED_CHANGED]: this.#onMediaLoadedChange,\n        [Event2.CAN_CONTROL_VOLUME_CHANGED]: this.#onCanControlVolumeChange,\n        [Event2.CAN_SEEK_CHANGED]: this.#onCanSeekChange,\n        [Event2.DURATION_CHANGED]: this.#onDurationChange,\n        [Event2.IS_MUTED_CHANGED]: this.#onVolumeChange,\n        [Event2.VOLUME_LEVEL_CHANGED]: this.#onVolumeChange,\n        [Event2.IS_PAUSED_CHANGED]: this.#onPausedChange,\n        [Event2.LIVE_SEEKABLE_RANGE_CHANGED]: this.#onProgress,\n        [Event2.PLAYER_STATE_CHANGED]: this.#onPlayerStateChange\n      };\n    this.#playerEventHandlers = handlers;\n    const handler = this.#onRemotePlayerEvent.bind(this);\n    for (const type of keysOf(handlers)) {\n      this.#player.controller.addEventListener(type, handler);\n    }\n    onDispose(() => {\n      for (const type of keysOf(handlers)) {\n        this.#player.controller.removeEventListener(type, handler);\n      }\n    });\n  }\n  async play() {\n    if (!this.#player.isPaused && !this.#isIdle) return;\n    if (this.#isIdle) {\n      await this.#reload(false, 0);\n      return;\n    }\n    this.#player.controller?.playOrPause();\n  }\n  async pause() {\n    if (this.#player.isPaused) return;\n    this.#player.controller?.playOrPause();\n  }\n  getMediaStatus(request) {\n    return new Promise((resolve, reject) => {\n      this.media?.getStatus(request, resolve, reject);\n    });\n  }\n  setMuted(muted) {\n    const hasChanged = muted && !this.#player.isMuted || !muted && this.#player.isMuted;\n    if (hasChanged) this.#player.controller?.muteOrUnmute();\n  }\n  setCurrentTime(time) {\n    this.#player.currentTime = time;\n    this.#ctx.notify(\"seeking\", time);\n    this.#player.controller?.seek();\n  }\n  setVolume(volume) {\n    this.#player.volumeLevel = volume;\n    this.#player.controller?.setVolumeLevel();\n  }\n  async loadSource(src) {\n    if (this.#reloadInfo?.src !== src) this.#reloadInfo = null;\n    if (hasActiveCastSession(src)) {\n      this.#resumeSession();\n      this.#currentSrc = src;\n      return;\n    }\n    this.#ctx.notify(\"load-start\");\n    const loadRequest = this.#buildLoadRequest(src),\n      errorCode = await this.session.loadMedia(loadRequest);\n    if (errorCode) {\n      this.#currentSrc = null;\n      this.#ctx.notify(\"error\", Error(getCastErrorMessage(errorCode)));\n      return;\n    }\n    this.#currentSrc = src;\n  }\n  destroy() {\n    this.#reset();\n    this.#endSession();\n  }\n  #reset() {\n    if (!this.#reloadInfo) {\n      this.#played = 0;\n      this.#seekableRange = new TimeRange(0, 0);\n    }\n    this.#timeRAF.stop();\n    this.#currentTime = 0;\n    this.#reloadInfo = null;\n  }\n  #resumeSession() {\n    const resumeSessionEvent = new DOMEvent(\"resume-session\", {\n      detail: this.session\n    });\n    this.#onMediaLoadedChange(resumeSessionEvent);\n    const {\n        muted,\n        volume,\n        savedState\n      } = this.#ctx.$state,\n      localState = savedState();\n    this.setCurrentTime(Math.max(this.#player.currentTime, localState?.currentTime ?? 0));\n    this.setMuted(muted());\n    this.setVolume(volume());\n    if (localState?.paused === false) this.play();\n  }\n  #endSession() {\n    this.cast.endCurrentSession(true);\n    const {\n      remotePlaybackLoader\n    } = this.#ctx.$state;\n    remotePlaybackLoader.set(null);\n  }\n  #disconnectFromReceiver() {\n    const {\n      savedState\n    } = this.#ctx.$state;\n    savedState.set({\n      paused: this.#player.isPaused,\n      currentTime: this.#player.currentTime\n    });\n    this.#endSession();\n  }\n  #onAnimationFrame() {\n    this.#onCurrentTimeChange();\n  }\n  #onRemotePlayerEvent(event) {\n    this.#playerEventHandlers[event.type].call(this, event);\n  }\n  #onCastStateChange(data) {\n    const castState = this.cast.getCastState(),\n      state = castState === cast.framework.CastState.CONNECTED ? \"connected\" : castState === cast.framework.CastState.CONNECTING ? \"connecting\" : \"disconnected\";\n    if (this.#state === state) return;\n    const detail = {\n        type: \"google-cast\",\n        state\n      },\n      trigger = this.#createEvent(data);\n    this.#state = state;\n    this.#ctx.notify(\"remote-playback-change\", detail, trigger);\n    if (state === \"disconnected\") {\n      this.#disconnectFromReceiver();\n    }\n  }\n  #onMediaLoadedChange(event) {\n    const hasLoaded = !!this.#player.isMediaLoaded;\n    if (!hasLoaded) return;\n    const src = peek(this.#ctx.$state.source);\n    Promise.resolve().then(() => {\n      if (src !== peek(this.#ctx.$state.source) || !this.#player.isMediaLoaded) return;\n      this.#reset();\n      const duration = this.#player.duration;\n      this.#seekableRange = new TimeRange(0, duration);\n      const detail = {\n          provider: this,\n          duration,\n          buffered: new TimeRange(0, 0),\n          seekable: this.#getSeekableRange()\n        },\n        trigger = this.#createEvent(event);\n      this.#ctx.notify(\"loaded-metadata\", void 0, trigger);\n      this.#ctx.notify(\"loaded-data\", void 0, trigger);\n      this.#ctx.notify(\"can-play\", detail, trigger);\n      this.#onCanControlVolumeChange();\n      this.#onCanSeekChange(event);\n      const {\n        volume,\n        muted\n      } = this.#ctx.$state;\n      this.setVolume(volume());\n      this.setMuted(muted());\n      this.#timeRAF.start();\n      this.#tracks.syncRemoteTracks(trigger);\n      this.#tracks.syncRemoteActiveIds(trigger);\n    });\n  }\n  #onCanControlVolumeChange() {\n    this.#ctx.$state.canSetVolume.set(this.#player.canControlVolume);\n  }\n  #onCanSeekChange(event) {\n    const trigger = this.#createEvent(event);\n    this.#ctx.notify(\"stream-type-change\", this.#getStreamType(), trigger);\n  }\n  #getStreamType() {\n    const streamType = this.#player.mediaInfo?.streamType;\n    return streamType === chrome.cast.media.StreamType.LIVE ? this.#player.canSeek ? \"live:dvr\" : \"live\" : \"on-demand\";\n  }\n  #onCurrentTimeChange() {\n    if (this.#reloadInfo) return;\n    const currentTime = this.#player.currentTime;\n    if (currentTime === this.#currentTime) return;\n    this.#ctx.notify(\"time-change\", currentTime);\n    if (currentTime > this.#played) {\n      this.#played = currentTime;\n      this.#onProgress();\n    }\n    if (this.#ctx.$state.seeking()) {\n      this.#ctx.notify(\"seeked\", currentTime);\n    }\n    this.#currentTime = currentTime;\n  }\n  #onDurationChange(event) {\n    if (!this.#player.isMediaLoaded || this.#reloadInfo) return;\n    const duration = this.#player.duration,\n      trigger = this.#createEvent(event);\n    this.#seekableRange = new TimeRange(0, duration);\n    this.#ctx.notify(\"duration-change\", duration, trigger);\n  }\n  #onVolumeChange(event) {\n    if (!this.#player.isMediaLoaded) return;\n    const detail = {\n        muted: this.#player.isMuted,\n        volume: this.#player.volumeLevel\n      },\n      trigger = this.#createEvent(event);\n    this.#ctx.notify(\"volume-change\", detail, trigger);\n  }\n  #onPausedChange(event) {\n    const trigger = this.#createEvent(event);\n    if (this.#player.isPaused) {\n      this.#ctx.notify(\"pause\", void 0, trigger);\n    } else {\n      this.#ctx.notify(\"play\", void 0, trigger);\n    }\n  }\n  #onProgress(event) {\n    const detail = {\n        seekable: this.#getSeekableRange(),\n        buffered: new TimeRange(0, this.#played)\n      },\n      trigger = event ? this.#createEvent(event) : void 0;\n    this.#ctx.notify(\"progress\", detail, trigger);\n  }\n  #onPlayerStateChange(event) {\n    const state = this.#player.playerState,\n      PlayerState = chrome.cast.media.PlayerState;\n    this.#isIdle = state === PlayerState.IDLE;\n    if (state === PlayerState.PAUSED) return;\n    const trigger = this.#createEvent(event);\n    switch (state) {\n      case PlayerState.PLAYING:\n        this.#ctx.notify(\"playing\", void 0, trigger);\n        break;\n      case PlayerState.BUFFERING:\n        this.#ctx.notify(\"waiting\", void 0, trigger);\n        break;\n      case PlayerState.IDLE:\n        this.#timeRAF.stop();\n        this.#ctx.notify(\"pause\");\n        this.#ctx.notify(\"end\");\n        break;\n    }\n  }\n  #getSeekableRange() {\n    return this.#player.liveSeekableRange ? new TimeRange(this.#player.liveSeekableRange.start, this.#player.liveSeekableRange.end) : this.#seekableRange;\n  }\n  #createEvent(detail) {\n    return detail instanceof Event ? detail : new DOMEvent(detail.type, {\n      detail\n    });\n  }\n  #buildMediaInfo(src) {\n    const {\n      streamType,\n      title,\n      poster\n    } = this.#ctx.$state;\n    return new GoogleCastMediaInfoBuilder(src).setMetadata(title(), poster()).setStreamType(streamType()).setTracks(this.#tracks.getLocalTextTracks()).build();\n  }\n  #buildLoadRequest(src) {\n    const mediaInfo = this.#buildMediaInfo(src),\n      request = new chrome.cast.media.LoadRequest(mediaInfo),\n      savedState = this.#ctx.$state.savedState();\n    request.autoplay = (this.#reloadInfo?.paused ?? savedState?.paused) === false;\n    request.currentTime = this.#reloadInfo?.time ?? savedState?.currentTime ?? 0;\n    return request;\n  }\n  async #reload(paused, time) {\n    const src = peek(this.#ctx.$state.source);\n    this.#reloadInfo = {\n      src,\n      paused,\n      time\n    };\n    await this.loadSource(src);\n  }\n  #onNewLocalTracks() {\n    this.#reload(this.#player.isPaused, this.#player.currentTime).catch(error => {\n      {\n        this.#ctx.logger?.errorGroup(\"[vidstack] cast failed to load new local tracks\").labelledLog(\"Error\", error).dispatch();\n      }\n    });\n  }\n}\nexport { GoogleCastProvider };","map":{"version":3,"names":["listenEvent","effect","untrack","createScope","keysOf","onDispose","DOMEvent","peek","ListSymbol","TimeRange","RAFLoop","getCastSessionMedia","getCastContext","getCastSession","hasActiveCastSession","listenCastContextEvent","getCastErrorMessage","GoogleCastMediaInfoBuilder","info","constructor","src","chrome","cast","media","MediaInfo","type","build","setStreamType","streamType","includes","StreamType","LIVE","BUFFERED","setTracks","tracks","map","buildCastTrack","setMetadata","title","poster","metadata","GenericMediaMetadata","images","url","#buildCastTrack","track","trackId","castTrack","Track","TrackType","TEXT","name","label","trackContentId","trackContentType","language","subtype","kind","toUpperCase","GoogleCastTracksManager","ctx","onNewLocalTracks","setup","syncRemoteActiveIds","bind","audioTracks","textTracks","syncLocalTracks","getLocalTextTracks","$state","filter","getLocalAudioTracks","#getLocalAudioTracks","getRemoteTracks","#getRemoteTracks","mediaInfo","getRemoteActiveIds","#getRemoteActiveIds","activeIds","activeLocalAudioTrack","find","selected","activeLocalTextTracks","mode","remoteAudioTracks","AUDIO","remoteAudioTrack","findRemoteTrack","push","length","remoteTextTracks","localTrack","remoteTextTrack","#syncLocalTracks","localTextTracks","isMediaLoaded","hasRemoteTrack","syncRemoteTracks","event","localAudioTracks","hasLocalTrack","findLocalTrack","localAudioTrack","id","toString","add","localTextTrack","toLowerCase","editRequest","EditTracksInfoRequest","editTracksInfo","catch","error","logger","errorGroup","labelledLog","dispatch","#editTracksInfo","request","Promise","resolve","reject","#findLocalTrack","localTracks","remoteTrack","isMatch","#findRemoteTrack","remoteTracks","#isMatch","GoogleCastProvider","$$PROVIDER_TYPE","scope","player","currentSrc","state","currentTime","played","seekableRange","timeRAF","onAnimationFrame","playerEventHandlers","reloadInfo","isIdle","session","hasActiveSession","attachCastContextEventListeners","attachCastPlayerEventListeners","notify","#attachCastContextEventListeners","framework","CastContextEventType","CAST_STATE_CHANGED","onCastStateChange","#attachCastPlayerEventListeners","Event2","RemotePlayerEventType","handlers","IS_CONNECTED_CHANGED","IS_MEDIA_LOADED_CHANGED","onMediaLoadedChange","CAN_CONTROL_VOLUME_CHANGED","onCanControlVolumeChange","CAN_SEEK_CHANGED","onCanSeekChange","DURATION_CHANGED","onDurationChange","IS_MUTED_CHANGED","onVolumeChange","VOLUME_LEVEL_CHANGED","IS_PAUSED_CHANGED","onPausedChange","LIVE_SEEKABLE_RANGE_CHANGED","onProgress","PLAYER_STATE_CHANGED","onPlayerStateChange","handler","onRemotePlayerEvent","controller","addEventListener","removeEventListener","play","isPaused","reload","playOrPause","pause","getMediaStatus","getStatus","setMuted","muted","hasChanged","isMuted","muteOrUnmute","setCurrentTime","time","seek","setVolume","volume","volumeLevel","setVolumeLevel","loadSource","resumeSession","loadRequest","buildLoadRequest","errorCode","loadMedia","Error","destroy","reset","endSession","#reset","stop","#resumeSession","resumeSessionEvent","detail","savedState","localState","Math","max","paused","#endSession","endCurrentSession","remotePlaybackLoader","set","disconnectFromReceiver","#disconnectFromReceiver","#onAnimationFrame","onCurrentTimeChange","#onRemotePlayerEvent","call","#onCastStateChange","data","castState","getCastState","CastState","CONNECTED","CONNECTING","trigger","createEvent","#onMediaLoadedChange","hasLoaded","source","then","duration","provider","buffered","seekable","getSeekableRange","start","#onCanControlVolumeChange","canSetVolume","canControlVolume","#onCanSeekChange","getStreamType","#getStreamType","canSeek","#onCurrentTimeChange","seeking","#onDurationChange","#onVolumeChange","#onPausedChange","#onProgress","#onPlayerStateChange","playerState","PlayerState","IDLE","PAUSED","PLAYING","BUFFERING","#getSeekableRange","liveSeekableRange","end","#createEvent","Event","buildMediaInfo","#buildMediaInfo","#buildLoadRequest","LoadRequest","autoplay","#reload","#onNewLocalTracks"],"sources":["/Users/wanghley/Workspace/Projects/wanghley.com/node_modules/@vidstack/react/dev/chunks/vidstack-Dybq7b7g.js"],"sourcesContent":["\"use client\"\n\nimport { listenEvent, effect, untrack, createScope, keysOf, onDispose, DOMEvent, peek } from './vidstack-CH225ns1.js';\nimport { ListSymbol, TimeRange, RAFLoop } from './vidstack-C-WrcxmD.js';\nimport { getCastSessionMedia, getCastContext, getCastSession, hasActiveCastSession, listenCastContextEvent, getCastErrorMessage } from './vidstack-C8ZxSSGF.js';\nimport 'react';\nimport '@floating-ui/dom';\n\nclass GoogleCastMediaInfoBuilder {\n  #info;\n  constructor(src) {\n    this.#info = new chrome.cast.media.MediaInfo(src.src, src.type);\n  }\n  build() {\n    return this.#info;\n  }\n  setStreamType(streamType) {\n    if (streamType.includes(\"live\")) {\n      this.#info.streamType = chrome.cast.media.StreamType.LIVE;\n    } else {\n      this.#info.streamType = chrome.cast.media.StreamType.BUFFERED;\n    }\n    return this;\n  }\n  setTracks(tracks) {\n    this.#info.tracks = tracks.map(this.#buildCastTrack);\n    return this;\n  }\n  setMetadata(title, poster) {\n    this.#info.metadata = new chrome.cast.media.GenericMediaMetadata();\n    this.#info.metadata.title = title;\n    this.#info.metadata.images = [{ url: poster }];\n    return this;\n  }\n  #buildCastTrack(track, trackId) {\n    const castTrack = new chrome.cast.media.Track(trackId, chrome.cast.media.TrackType.TEXT);\n    castTrack.name = track.label;\n    castTrack.trackContentId = track.src;\n    castTrack.trackContentType = \"text/vtt\";\n    castTrack.language = track.language;\n    castTrack.subtype = track.kind.toUpperCase();\n    return castTrack;\n  }\n}\n\nclass GoogleCastTracksManager {\n  #cast;\n  #ctx;\n  #onNewLocalTracks;\n  constructor(cast, ctx, onNewLocalTracks) {\n    this.#cast = cast;\n    this.#ctx = ctx;\n    this.#onNewLocalTracks = onNewLocalTracks;\n  }\n  setup() {\n    const syncRemoteActiveIds = this.syncRemoteActiveIds.bind(this);\n    listenEvent(this.#ctx.audioTracks, \"change\", syncRemoteActiveIds);\n    listenEvent(this.#ctx.textTracks, \"mode-change\", syncRemoteActiveIds);\n    effect(this.#syncLocalTracks.bind(this));\n  }\n  getLocalTextTracks() {\n    return this.#ctx.$state.textTracks().filter((track) => track.src && track.type === \"vtt\");\n  }\n  #getLocalAudioTracks() {\n    return this.#ctx.$state.audioTracks();\n  }\n  #getRemoteTracks(type) {\n    const tracks = this.#cast.mediaInfo?.tracks ?? [];\n    return type ? tracks.filter((track) => track.type === type) : tracks;\n  }\n  #getRemoteActiveIds() {\n    const activeIds = [], activeLocalAudioTrack = this.#getLocalAudioTracks().find((track) => track.selected), activeLocalTextTracks = this.getLocalTextTracks().filter((track) => track.mode === \"showing\");\n    if (activeLocalAudioTrack) {\n      const remoteAudioTracks = this.#getRemoteTracks(chrome.cast.media.TrackType.AUDIO), remoteAudioTrack = this.#findRemoteTrack(remoteAudioTracks, activeLocalAudioTrack);\n      if (remoteAudioTrack) activeIds.push(remoteAudioTrack.trackId);\n    }\n    if (activeLocalTextTracks?.length) {\n      const remoteTextTracks = this.#getRemoteTracks(chrome.cast.media.TrackType.TEXT);\n      if (remoteTextTracks.length) {\n        for (const localTrack of activeLocalTextTracks) {\n          const remoteTextTrack = this.#findRemoteTrack(remoteTextTracks, localTrack);\n          if (remoteTextTrack) activeIds.push(remoteTextTrack.trackId);\n        }\n      }\n    }\n    return activeIds;\n  }\n  #syncLocalTracks() {\n    const localTextTracks = this.getLocalTextTracks();\n    if (!this.#cast.isMediaLoaded) return;\n    const remoteTextTracks = this.#getRemoteTracks(chrome.cast.media.TrackType.TEXT);\n    for (const localTrack of localTextTracks) {\n      const hasRemoteTrack = this.#findRemoteTrack(remoteTextTracks, localTrack);\n      if (!hasRemoteTrack) {\n        untrack(() => this.#onNewLocalTracks?.());\n        break;\n      }\n    }\n  }\n  syncRemoteTracks(event) {\n    if (!this.#cast.isMediaLoaded) return;\n    const localAudioTracks = this.#getLocalAudioTracks(), localTextTracks = this.getLocalTextTracks(), remoteAudioTracks = this.#getRemoteTracks(chrome.cast.media.TrackType.AUDIO), remoteTextTracks = this.#getRemoteTracks(chrome.cast.media.TrackType.TEXT);\n    for (const remoteAudioTrack of remoteAudioTracks) {\n      const hasLocalTrack = this.#findLocalTrack(localAudioTracks, remoteAudioTrack);\n      if (hasLocalTrack) continue;\n      const localAudioTrack = {\n        id: remoteAudioTrack.trackId.toString(),\n        label: remoteAudioTrack.name,\n        language: remoteAudioTrack.language,\n        kind: remoteAudioTrack.subtype ?? \"main\",\n        selected: false\n      };\n      this.#ctx.audioTracks[ListSymbol.add](localAudioTrack, event);\n    }\n    for (const remoteTextTrack of remoteTextTracks) {\n      const hasLocalTrack = this.#findLocalTrack(localTextTracks, remoteTextTrack);\n      if (hasLocalTrack) continue;\n      const localTextTrack = {\n        id: remoteTextTrack.trackId.toString(),\n        src: remoteTextTrack.trackContentId,\n        label: remoteTextTrack.name,\n        language: remoteTextTrack.language,\n        kind: remoteTextTrack.subtype.toLowerCase()\n      };\n      this.#ctx.textTracks.add(localTextTrack, event);\n    }\n  }\n  syncRemoteActiveIds(event) {\n    if (!this.#cast.isMediaLoaded) return;\n    const activeIds = this.#getRemoteActiveIds(), editRequest = new chrome.cast.media.EditTracksInfoRequest(activeIds);\n    this.#editTracksInfo(editRequest).catch((error) => {\n      {\n        this.#ctx.logger?.errorGroup(\"[vidstack] failed to edit cast tracks info\").labelledLog(\"Edit Request\", editRequest).labelledLog(\"Error\", error).dispatch();\n      }\n    });\n  }\n  #editTracksInfo(request) {\n    const media = getCastSessionMedia();\n    return new Promise((resolve, reject) => media?.editTracksInfo(request, resolve, reject));\n  }\n  #findLocalTrack(localTracks, remoteTrack) {\n    return localTracks.find((localTrack) => this.#isMatch(localTrack, remoteTrack));\n  }\n  #findRemoteTrack(remoteTracks, localTrack) {\n    return remoteTracks.find((remoteTrack) => this.#isMatch(localTrack, remoteTrack));\n  }\n  // Note: we can't rely on id matching because they will differ between local/remote. A local\n  // track id might not even exist.\n  #isMatch(localTrack, remoteTrack) {\n    return remoteTrack.name === localTrack.label && remoteTrack.language === localTrack.language && remoteTrack.subtype.toLowerCase() === localTrack.kind.toLowerCase();\n  }\n}\n\nclass GoogleCastProvider {\n  $$PROVIDER_TYPE = \"GOOGLE_CAST\";\n  scope = createScope();\n  #player;\n  #ctx;\n  #tracks;\n  #currentSrc = null;\n  #state = \"disconnected\";\n  #currentTime = 0;\n  #played = 0;\n  #seekableRange = new TimeRange(0, 0);\n  #timeRAF = new RAFLoop(this.#onAnimationFrame.bind(this));\n  #playerEventHandlers;\n  #reloadInfo = null;\n  #isIdle = false;\n  constructor(player, ctx) {\n    this.#player = player;\n    this.#ctx = ctx;\n    this.#tracks = new GoogleCastTracksManager(player, ctx, this.#onNewLocalTracks.bind(this));\n  }\n  get type() {\n    return \"google-cast\";\n  }\n  get currentSrc() {\n    return this.#currentSrc;\n  }\n  /**\n   * The Google Cast remote player.\n   *\n   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.RemotePlayer}\n   */\n  get player() {\n    return this.#player;\n  }\n  /**\n   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastContext}\n   */\n  get cast() {\n    return getCastContext();\n  }\n  /**\n   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastSession}\n   */\n  get session() {\n    return getCastSession();\n  }\n  /**\n   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/chrome.cast.media.Media}\n   */\n  get media() {\n    return getCastSessionMedia();\n  }\n  /**\n   * Whether the current Google Cast session belongs to this provider.\n   */\n  get hasActiveSession() {\n    return hasActiveCastSession(this.#currentSrc);\n  }\n  setup() {\n    this.#attachCastContextEventListeners();\n    this.#attachCastPlayerEventListeners();\n    this.#tracks.setup();\n    this.#ctx.notify(\"provider-setup\", this);\n  }\n  #attachCastContextEventListeners() {\n    listenCastContextEvent(\n      cast.framework.CastContextEventType.CAST_STATE_CHANGED,\n      this.#onCastStateChange.bind(this)\n    );\n  }\n  #attachCastPlayerEventListeners() {\n    const Event2 = cast.framework.RemotePlayerEventType, handlers = {\n      [Event2.IS_CONNECTED_CHANGED]: this.#onCastStateChange,\n      [Event2.IS_MEDIA_LOADED_CHANGED]: this.#onMediaLoadedChange,\n      [Event2.CAN_CONTROL_VOLUME_CHANGED]: this.#onCanControlVolumeChange,\n      [Event2.CAN_SEEK_CHANGED]: this.#onCanSeekChange,\n      [Event2.DURATION_CHANGED]: this.#onDurationChange,\n      [Event2.IS_MUTED_CHANGED]: this.#onVolumeChange,\n      [Event2.VOLUME_LEVEL_CHANGED]: this.#onVolumeChange,\n      [Event2.IS_PAUSED_CHANGED]: this.#onPausedChange,\n      [Event2.LIVE_SEEKABLE_RANGE_CHANGED]: this.#onProgress,\n      [Event2.PLAYER_STATE_CHANGED]: this.#onPlayerStateChange\n    };\n    this.#playerEventHandlers = handlers;\n    const handler = this.#onRemotePlayerEvent.bind(this);\n    for (const type of keysOf(handlers)) {\n      this.#player.controller.addEventListener(type, handler);\n    }\n    onDispose(() => {\n      for (const type of keysOf(handlers)) {\n        this.#player.controller.removeEventListener(type, handler);\n      }\n    });\n  }\n  async play() {\n    if (!this.#player.isPaused && !this.#isIdle) return;\n    if (this.#isIdle) {\n      await this.#reload(false, 0);\n      return;\n    }\n    this.#player.controller?.playOrPause();\n  }\n  async pause() {\n    if (this.#player.isPaused) return;\n    this.#player.controller?.playOrPause();\n  }\n  getMediaStatus(request) {\n    return new Promise((resolve, reject) => {\n      this.media?.getStatus(request, resolve, reject);\n    });\n  }\n  setMuted(muted) {\n    const hasChanged = muted && !this.#player.isMuted || !muted && this.#player.isMuted;\n    if (hasChanged) this.#player.controller?.muteOrUnmute();\n  }\n  setCurrentTime(time) {\n    this.#player.currentTime = time;\n    this.#ctx.notify(\"seeking\", time);\n    this.#player.controller?.seek();\n  }\n  setVolume(volume) {\n    this.#player.volumeLevel = volume;\n    this.#player.controller?.setVolumeLevel();\n  }\n  async loadSource(src) {\n    if (this.#reloadInfo?.src !== src) this.#reloadInfo = null;\n    if (hasActiveCastSession(src)) {\n      this.#resumeSession();\n      this.#currentSrc = src;\n      return;\n    }\n    this.#ctx.notify(\"load-start\");\n    const loadRequest = this.#buildLoadRequest(src), errorCode = await this.session.loadMedia(loadRequest);\n    if (errorCode) {\n      this.#currentSrc = null;\n      this.#ctx.notify(\"error\", Error(getCastErrorMessage(errorCode)));\n      return;\n    }\n    this.#currentSrc = src;\n  }\n  destroy() {\n    this.#reset();\n    this.#endSession();\n  }\n  #reset() {\n    if (!this.#reloadInfo) {\n      this.#played = 0;\n      this.#seekableRange = new TimeRange(0, 0);\n    }\n    this.#timeRAF.stop();\n    this.#currentTime = 0;\n    this.#reloadInfo = null;\n  }\n  #resumeSession() {\n    const resumeSessionEvent = new DOMEvent(\"resume-session\", { detail: this.session });\n    this.#onMediaLoadedChange(resumeSessionEvent);\n    const { muted, volume, savedState } = this.#ctx.$state, localState = savedState();\n    this.setCurrentTime(Math.max(this.#player.currentTime, localState?.currentTime ?? 0));\n    this.setMuted(muted());\n    this.setVolume(volume());\n    if (localState?.paused === false) this.play();\n  }\n  #endSession() {\n    this.cast.endCurrentSession(true);\n    const { remotePlaybackLoader } = this.#ctx.$state;\n    remotePlaybackLoader.set(null);\n  }\n  #disconnectFromReceiver() {\n    const { savedState } = this.#ctx.$state;\n    savedState.set({\n      paused: this.#player.isPaused,\n      currentTime: this.#player.currentTime\n    });\n    this.#endSession();\n  }\n  #onAnimationFrame() {\n    this.#onCurrentTimeChange();\n  }\n  #onRemotePlayerEvent(event) {\n    this.#playerEventHandlers[event.type].call(this, event);\n  }\n  #onCastStateChange(data) {\n    const castState = this.cast.getCastState(), state = castState === cast.framework.CastState.CONNECTED ? \"connected\" : castState === cast.framework.CastState.CONNECTING ? \"connecting\" : \"disconnected\";\n    if (this.#state === state) return;\n    const detail = { type: \"google-cast\", state }, trigger = this.#createEvent(data);\n    this.#state = state;\n    this.#ctx.notify(\"remote-playback-change\", detail, trigger);\n    if (state === \"disconnected\") {\n      this.#disconnectFromReceiver();\n    }\n  }\n  #onMediaLoadedChange(event) {\n    const hasLoaded = !!this.#player.isMediaLoaded;\n    if (!hasLoaded) return;\n    const src = peek(this.#ctx.$state.source);\n    Promise.resolve().then(() => {\n      if (src !== peek(this.#ctx.$state.source) || !this.#player.isMediaLoaded) return;\n      this.#reset();\n      const duration = this.#player.duration;\n      this.#seekableRange = new TimeRange(0, duration);\n      const detail = {\n        provider: this,\n        duration,\n        buffered: new TimeRange(0, 0),\n        seekable: this.#getSeekableRange()\n      }, trigger = this.#createEvent(event);\n      this.#ctx.notify(\"loaded-metadata\", void 0, trigger);\n      this.#ctx.notify(\"loaded-data\", void 0, trigger);\n      this.#ctx.notify(\"can-play\", detail, trigger);\n      this.#onCanControlVolumeChange();\n      this.#onCanSeekChange(event);\n      const { volume, muted } = this.#ctx.$state;\n      this.setVolume(volume());\n      this.setMuted(muted());\n      this.#timeRAF.start();\n      this.#tracks.syncRemoteTracks(trigger);\n      this.#tracks.syncRemoteActiveIds(trigger);\n    });\n  }\n  #onCanControlVolumeChange() {\n    this.#ctx.$state.canSetVolume.set(this.#player.canControlVolume);\n  }\n  #onCanSeekChange(event) {\n    const trigger = this.#createEvent(event);\n    this.#ctx.notify(\"stream-type-change\", this.#getStreamType(), trigger);\n  }\n  #getStreamType() {\n    const streamType = this.#player.mediaInfo?.streamType;\n    return streamType === chrome.cast.media.StreamType.LIVE ? this.#player.canSeek ? \"live:dvr\" : \"live\" : \"on-demand\";\n  }\n  #onCurrentTimeChange() {\n    if (this.#reloadInfo) return;\n    const currentTime = this.#player.currentTime;\n    if (currentTime === this.#currentTime) return;\n    this.#ctx.notify(\"time-change\", currentTime);\n    if (currentTime > this.#played) {\n      this.#played = currentTime;\n      this.#onProgress();\n    }\n    if (this.#ctx.$state.seeking()) {\n      this.#ctx.notify(\"seeked\", currentTime);\n    }\n    this.#currentTime = currentTime;\n  }\n  #onDurationChange(event) {\n    if (!this.#player.isMediaLoaded || this.#reloadInfo) return;\n    const duration = this.#player.duration, trigger = this.#createEvent(event);\n    this.#seekableRange = new TimeRange(0, duration);\n    this.#ctx.notify(\"duration-change\", duration, trigger);\n  }\n  #onVolumeChange(event) {\n    if (!this.#player.isMediaLoaded) return;\n    const detail = {\n      muted: this.#player.isMuted,\n      volume: this.#player.volumeLevel\n    }, trigger = this.#createEvent(event);\n    this.#ctx.notify(\"volume-change\", detail, trigger);\n  }\n  #onPausedChange(event) {\n    const trigger = this.#createEvent(event);\n    if (this.#player.isPaused) {\n      this.#ctx.notify(\"pause\", void 0, trigger);\n    } else {\n      this.#ctx.notify(\"play\", void 0, trigger);\n    }\n  }\n  #onProgress(event) {\n    const detail = {\n      seekable: this.#getSeekableRange(),\n      buffered: new TimeRange(0, this.#played)\n    }, trigger = event ? this.#createEvent(event) : void 0;\n    this.#ctx.notify(\"progress\", detail, trigger);\n  }\n  #onPlayerStateChange(event) {\n    const state = this.#player.playerState, PlayerState = chrome.cast.media.PlayerState;\n    this.#isIdle = state === PlayerState.IDLE;\n    if (state === PlayerState.PAUSED) return;\n    const trigger = this.#createEvent(event);\n    switch (state) {\n      case PlayerState.PLAYING:\n        this.#ctx.notify(\"playing\", void 0, trigger);\n        break;\n      case PlayerState.BUFFERING:\n        this.#ctx.notify(\"waiting\", void 0, trigger);\n        break;\n      case PlayerState.IDLE:\n        this.#timeRAF.stop();\n        this.#ctx.notify(\"pause\");\n        this.#ctx.notify(\"end\");\n        break;\n    }\n  }\n  #getSeekableRange() {\n    return this.#player.liveSeekableRange ? new TimeRange(this.#player.liveSeekableRange.start, this.#player.liveSeekableRange.end) : this.#seekableRange;\n  }\n  #createEvent(detail) {\n    return detail instanceof Event ? detail : new DOMEvent(detail.type, { detail });\n  }\n  #buildMediaInfo(src) {\n    const { streamType, title, poster } = this.#ctx.$state;\n    return new GoogleCastMediaInfoBuilder(src).setMetadata(title(), poster()).setStreamType(streamType()).setTracks(this.#tracks.getLocalTextTracks()).build();\n  }\n  #buildLoadRequest(src) {\n    const mediaInfo = this.#buildMediaInfo(src), request = new chrome.cast.media.LoadRequest(mediaInfo), savedState = this.#ctx.$state.savedState();\n    request.autoplay = (this.#reloadInfo?.paused ?? savedState?.paused) === false;\n    request.currentTime = this.#reloadInfo?.time ?? savedState?.currentTime ?? 0;\n    return request;\n  }\n  async #reload(paused, time) {\n    const src = peek(this.#ctx.$state.source);\n    this.#reloadInfo = { src, paused, time };\n    await this.loadSource(src);\n  }\n  #onNewLocalTracks() {\n    this.#reload(this.#player.isPaused, this.#player.currentTime).catch((error) => {\n      {\n        this.#ctx.logger?.errorGroup(\"[vidstack] cast failed to load new local tracks\").labelledLog(\"Error\", error).dispatch();\n      }\n    });\n  }\n}\n\nexport { GoogleCastProvider };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}